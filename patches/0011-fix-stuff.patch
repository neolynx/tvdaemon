From 8d4391c1050daa81183dbd6f9350a8f025887670 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Andr=C3=A9=20Roth?= <neolynx@gmail.com>
Date: Wed, 24 Dec 2014 22:24:33 +0100
Subject: [PATCH 11/12] fix stuff

---
 lib/libdvbv5/descriptors.c | 21 +++++++++----
 lib/libdvbv5/dvb-scan.c    | 73 ----------------------------------------------
 2 files changed, 16 insertions(+), 78 deletions(-)

diff --git a/lib/libdvbv5/descriptors.c b/lib/libdvbv5/descriptors.c
index 21423e9..0231cc7 100644
--- a/lib/libdvbv5/descriptors.c
+++ b/lib/libdvbv5/descriptors.c
@@ -60,6 +60,17 @@
 
 #include "dvb-fe-priv.h"
 
+#ifdef ENABLE_NLS
+# include "gettext.h"
+# include <libintl.h>
+# define _(string) dgettext(LIBDVBV5_DOMAIN, string)
+
+#else
+# define _(string) string
+#endif
+
+# define N_(string) string
+
 struct dvb_desc *dvb_desc_create(struct dvb_v5_fe_parms *parms, uint8_t type, struct dvb_desc **list)
 {
 	dvb_desc_create_func create = dvb_descriptors[type].create;
@@ -163,11 +174,11 @@ int dvb_parse_section(struct dvb_v5_fe_parms_priv *priv,
 	dvb_table_header_init(&h);
 
 	if (priv->p.verbose)
-		dvb_log("%s: received table 0x%02x, TS ID 0x%04x, section %d/%d",
+		dvb_log(_("%s: received table 0x%02x, TS ID 0x%04x, section %d/%d"),
 			__func__, h.table_id, h.id, h.section_id, h.last_section);
 
 	if (sect->tid != h.table_id) {
-		dvb_logdbg("%s: couldn't match ID %d at the active section filters",
+		dvb_logdbg(_("%s: couldn't match ID %d at the active section filters"),
 			   __func__, h.table_id);
 		return -1;
 	}
@@ -188,7 +199,7 @@ int dvb_parse_section(struct dvb_v5_fe_parms_priv *priv,
 			/* tables like EIT can increment sections by gaps > 1.
 			 * in this case, reading is done when a already read
 			 * table is reached. */
-			dvb_log("%s: section repeated, reading done", __func__);
+			dvb_log(_("%s: section repeated, reading done"), __func__);
 			filter_priv->done = 1;
 			return 1;
 		}
@@ -206,11 +217,11 @@ int dvb_parse_section(struct dvb_v5_fe_parms_priv *priv,
 		set_bit(h.section_id, filter_priv->is_read_bits);
 
 	if (dvb_table_initializers[tid].init)
-		dvb_table_initializers[tid].init(parms, buf,
+		dvb_table_initializers[tid].init(&priv->p, buf,
 					    buf_length - DVB_CRC_SIZE,
 					    sect->table);
 	else
-		dvb_logerr("%s: no initializer for table %d",
+		dvb_logerr(_("%s: no initializer for table %d"),
 			   __func__, tid);
 
 	if (!sect->allow_section_gaps && sect->ts_id == -1 &&
diff --git a/lib/libdvbv5/dvb-scan.c b/lib/libdvbv5/dvb-scan.c
index 140655d..607028d 100644
--- a/lib/libdvbv5/dvb-scan.c
+++ b/lib/libdvbv5/dvb-scan.c
@@ -136,79 +136,6 @@ void dvb_table_filter_free(struct dvb_table_filter *sect)
 	}
 }
 
-static int dvb_parse_section(struct dvb_v5_fe_parms_priv *parms,
-			     struct dvb_table_filter *sect,
-			     const uint8_t *buf, ssize_t buf_length)
-{
-	struct dvb_table_header h;
-	struct dvb_table_filter_priv *priv;
-	unsigned char tid;
-
-	memcpy(&h, buf, sizeof(struct dvb_table_header));
-	dvb_table_header_init(&h);
-
-	if (parms->p.verbose)
-		dvb_log(_("%s: received table 0x%02x, TS ID 0x%04x, section %d/%d"),
-			__func__, h.table_id, h.id, h.section_id, h.last_section);
-
-	if (sect->tid != h.table_id) {
-		dvb_logdbg(_("%s: couldn't match ID %d at the active section filters"),
-			   __func__, h.table_id);
-		return -1;
-	}
-	priv = sect->priv;
-	tid = h.table_id;
-
-	if (priv->first_ts_id < 0)
-		priv->first_ts_id = h.id;
-	if (priv->first_section < 0)
-		priv->first_section = h.section_id;
-	if (priv->last_section < 0)
-		priv->last_section = h.last_section;
-	else { /* Check if the table was already parsed, but not on first pass */
-		if (!sect->allow_section_gaps && sect->ts_id == -1) {
-			if (test_bit(h.section_id, priv->is_read_bits))
-				return 0;
-		} else if (priv->first_ts_id == h.id && priv->first_section == h.section_id) {
-			/* tables like EIT can increment sections by gaps > 1.
-			 * in this case, reading is done when a already read
-			 * table is reached. */
-			dvb_log(_("%s: section repeated, reading done"), __func__);
-			priv->done = 1;
-			return 1;
-		}
-	}
-
-
-	/* search for an specific TS ID */
-	if (sect->ts_id != -1) {
-		if (h.id != sect->ts_id)
-			return 0;
-	}
-
-	/* handle the sections */
-	if (!sect->allow_section_gaps && sect->ts_id == -1)
-		set_bit(h.section_id, priv->is_read_bits);
-
-	if (dvb_table_initializers[tid])
-		dvb_table_initializers[tid](&parms->p, buf,
-					    buf_length - DVB_CRC_SIZE,
-					    sect->table);
-	else
-		dvb_logerr(_("%s: no initializer for table %d"),
-			   __func__, tid);
-
-	if (!sect->allow_section_gaps && sect->ts_id == -1 &&
-			is_all_bits_set(priv->last_section, priv->is_read_bits))
-		priv->done = 1;
-
-	if (!priv->done)
-		return 0;
-
-	/* Section was fully parsed */
-	return 1;
-}
-
 int dvb_read_sections(struct dvb_v5_fe_parms *__p, int dmx_fd,
 			     struct dvb_table_filter *sect,
 			     unsigned timeout)
-- 
1.8.3.2

