From 4e409fb7300eb80bda6fa5dcc1eaa1b926d11440 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Andr=C3=A9=20Roth?= <neolynx@gmail.com>
Date: Sun, 23 Nov 2014 15:10:22 +0100
Subject: [PATCH 07/12] libdvbv5: support different parsers per table
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Not all DVB tables use the same headers. This patch allows using a
different parser for tables with a header other than struct
dvb_table_header.

Signed-off-by: Andr√© Roth <neolynx@gmail.com>
---
 lib/include/libdvbv5/descriptors.h | 112 ++++++++++++++++++++++++++++++++++++-
 lib/include/libdvbv5/dvb-scan.h    |  30 ----------
 lib/libdvbv5/descriptors.c         | 109 +++++++++++++++++++++++++++++++++++-
 lib/libdvbv5/dvb-scan.c            |  49 ++--------------
 4 files changed, 223 insertions(+), 77 deletions(-)

diff --git a/lib/include/libdvbv5/descriptors.h b/lib/include/libdvbv5/descriptors.h
index 765cc2d..e22ec96 100644
--- a/lib/include/libdvbv5/descriptors.h
+++ b/lib/include/libdvbv5/descriptors.h
@@ -67,6 +67,37 @@ struct dvb_v5_fe_parms;
 #endif
 
 /**
+ * @struct dvb_table_filter
+ * @brief Describes the PES filters used by DVB scan
+ * @ingroup frontend_scan
+ *
+ * @param tid		Table ID
+ * @param pid		Program ID
+ * @param ts_id		Table section ID (for multisession filtering). If no
+ *			specific table section is needed, -1 should be used
+ * @param table		pointer to a pointer for the table struct to be filled
+ * @param allow_section_gaps	Allow non-continuous section numbering
+ * @param priv		Internal structure used inside the DVB core. shouldn't
+ *			be touched externally.
+ */
+struct dvb_table_filter {
+	/* Input data */
+	unsigned char tid;
+	uint16_t pid;
+	int ts_id;
+	void **table;
+
+	int allow_section_gaps;
+
+	/*
+	 * Private temp data used by dvb_read_sections().
+	 * Should not be filled outside dvb-scan.c, as they'll be
+	 * overrided
+	 */
+	void *priv;
+};
+
+/**
  * @brief Function prototype for a function that initializes the
  *	  descriptors parsing on a table
  * @ingroup dvb_table
@@ -81,11 +112,90 @@ typedef void (*dvb_table_init_func)(struct dvb_v5_fe_parms *parms,
 				    const uint8_t *buf, ssize_t buflen,
 				    void **table);
 
+
+/*
+ * The code below was inspired on Linux Kernel's bitmask implementation
+ */
+
+#define BITS_PER_LONG		(8 * sizeof(long))
+#define BIT_MASK(nr)		(1UL << ((nr) % BITS_PER_LONG))
+#define BIT_WORD(nr)		((nr) / BITS_PER_LONG)
+#define BITS_TO_LONGS(nr)	((nr +BITS_PER_LONG - 1) / BITS_PER_LONG)
+
+/**
+ * @struct dvb_table_filter_priv
+ * @brief Internal table for filtering
+ * @ingroup dvb_table
+ *
+ * @param last_section   Internal
+ * @param is_read_bits   Internal
+ * @param first_ts_id	 Internal
+ * @param first_section  Internal
+ * @param done		 Parsing done
+ */
+struct dvb_table_filter_priv {
+	int last_section;
+	unsigned long is_read_bits[BITS_TO_LONGS(256)];
+
+	/* section gaps and multiple ts_id handling */
+	int first_ts_id;
+	int first_section;
+	int done;
+};
+
+/* predeclaration of private data */
+struct dvb_v5_fe_parms_priv;
+
+/**
+ * @brief Function prototype for a function that parses the
+ *	  table and descriptors
+ * @ingroup dvb_table
+ *
+ * @param priv		Private parser data
+ * @param sect		Pointer to filter data
+ * @param buf		Buffer with data to be parsed
+ * @param buflen	Size of the buffer to be parsed
+ *
+ * @return		Returns 0 on success, a negative value otherwise
+ *
+ */
+typedef int (*dvb_table_parse_func)(struct dvb_v5_fe_parms_priv *priv,
+			     struct dvb_table_filter *sect,
+			     const uint8_t *buf, ssize_t buf_length);
+
+/**
+ * @brief Parses a DVB table and descriptors
+ * @ingroup dvb_table
+ *
+ * @param priv		Private parser data
+ * @param sect		Pointer to filter data
+ * @param buf		Buffer with data to be parsed
+ * @param buflen	Size of the buffer to be parsed
+ *
+ * @return		Returns 0 on success, a negative value otherwise
+ */
+int dvb_parse_section(struct dvb_v5_fe_parms_priv *priv,
+			     struct dvb_table_filter *sect,
+			     const uint8_t *buf, ssize_t buf_length);
+
+/**
+ * @struct dvb_initializer
+ * @brief Function pointers to initialize and parse a DVB table
+ * @ingroup dvb_table
+ *
+ * @param init		Pointer to init function
+ * @param parse		Pointer to parse function
+ */
+struct dvb_initializer {
+	dvb_table_init_func init;
+	dvb_table_parse_func parse;
+};
+
 /**
  * @brief Table with all possible descriptors
  * @ingroup dvb_table
  */
-extern const dvb_table_init_func dvb_table_initializers[256];
+extern struct dvb_initializer dvb_table_initializers[256];
 
 #ifndef _DOXYGEN
 #define bswap16(b) do {\
diff --git a/lib/include/libdvbv5/dvb-scan.h b/lib/include/libdvbv5/dvb-scan.h
index c480426..b0401bd 100644
--- a/lib/include/libdvbv5/dvb-scan.h
+++ b/lib/include/libdvbv5/dvb-scan.h
@@ -91,36 +91,6 @@ struct dvb_v5_descriptors {
 };
 
 /**
- * @struct dvb_table_filter
- * @brief Describes the PES filters used by DVB scan
- * @ingroup frontend_scan
- *
- * @param tid		Table ID
- * @param pid		Program ID
- * @param ts_id		Table section ID (for multisession filtering). If no
- *			specific table section is needed, -1 should be used
- * @param table		pointer to a pointer for the table struct to be filled
- * @param allow_section_gaps	Allow non-continuous section numbering
- * @param priv		Internal structure used inside the DVB core. shouldn't
- *			be touched externally.
- */
-struct dvb_table_filter {
-	/* Input data */
-	unsigned char tid;
-	uint16_t pid;
-	int ts_id;
-	void **table;
-
-	int allow_section_gaps;
-
-	/*
-	 * Private temp data used by dvb_read_sections().
-	 * Should not be filled outside dvb-scan.c, as they'll be
-	 * overrided
-	 */
-	void *priv;
-};
-/**
  * @brief deallocates all data associated with a table filter
  * @ingroup frontend_scan
  *
diff --git a/lib/libdvbv5/descriptors.c b/lib/libdvbv5/descriptors.c
index 0dce958..0a6e072 100644
--- a/lib/libdvbv5/descriptors.c
+++ b/lib/libdvbv5/descriptors.c
@@ -57,6 +57,8 @@
 #include <libdvbv5/desc_ca_identifier.h>
 #include <libdvbv5/desc_extension.h>
 
+#include "dvb-fe-priv.h"
+
 struct dvb_desc *dvb_desc_create(struct dvb_v5_fe_parms *parms, uint8_t type, struct dvb_desc **list)
 {
 	dvb_desc_create_func create = dvb_descriptors[type].create;
@@ -78,6 +80,32 @@ struct dvb_desc *dvb_desc_create(struct dvb_v5_fe_parms *parms, uint8_t type, st
 
 }
 
+/*
+ * The code below was inspired on Linux Kernel's bitmask implementation
+ */
+static void set_bit(int nr, unsigned long *addr)
+{
+	unsigned long mask = BIT_MASK(nr);
+	unsigned long *p = addr + BIT_WORD(nr);
+
+	*p  |= mask;
+}
+
+static int test_bit(int nr, unsigned long *addr)
+{
+	unsigned long mask = BIT_MASK(nr);
+	unsigned long *p = addr + BIT_WORD(nr);
+
+	return (*p & mask) ? -1 : 0;
+}
+
+static int is_all_bits_set(int nr, unsigned long *addr)
+{
+	unsigned long mask = BIT_MASK(nr + 1) - 1;
+
+	return (*addr == mask);
+}
+
 static void dvb_desc_init(uint8_t type, uint8_t length, struct dvb_desc *desc)
 {
 	desc->type   = type;
@@ -102,10 +130,11 @@ static void dvb_desc_default_print(struct dvb_v5_fe_parms *parms, const struct d
 	dvb_hexdump(parms, "|           ", desc->data, desc->length);
 }
 
-#define TABLE_INIT(_x) (dvb_table_init_func) _x##_init
+#define TABLE_INIT(_x) { (dvb_table_init_func) _x##_init, dvb_parse_section }
+#define TABLE_INIT2(_x,_y) { (dvb_table_init_func) _x##_init, _y }
 
-const dvb_table_init_func dvb_table_initializers[256] = {
-	[0 ... 255]              = NULL,
+struct dvb_initializer dvb_table_initializers[256] = {
+	[0 ... 255]              = { NULL, NULL },
 	[DVB_TABLE_PAT]          = TABLE_INIT(dvb_table_pat),
 	[DVB_TABLE_CAT]          = TABLE_INIT(dvb_table_cat),
 	[DVB_TABLE_PMT]          = TABLE_INIT(dvb_table_pmt),
@@ -119,6 +148,80 @@ const dvb_table_init_func dvb_table_initializers[256] = {
 	[ATSC_TABLE_CVCT]        = TABLE_INIT(atsc_table_vct),
 };
 
+int dvb_parse_section(struct dvb_v5_fe_parms_priv *priv,
+			     struct dvb_table_filter *sect,
+			     const uint8_t *buf, ssize_t buf_length)
+{
+	struct dvb_table_header h;
+	struct dvb_table_filter_priv *filter_priv;
+	unsigned char tid;
+	struct dvb_v5_fe_parms *parms = &priv->p;
+
+	memcpy(&h, buf, sizeof(struct dvb_table_header));
+	dvb_table_header_init(&h);
+
+	if (priv->p.verbose)
+		dvb_log("%s: received table 0x%02x, TS ID 0x%04x, section %d/%d",
+			__func__, h.table_id, h.id, h.section_id, h.last_section);
+
+	if (sect->tid != h.table_id) {
+		dvb_logdbg("%s: couldn't match ID %d at the active section filters",
+			   __func__, h.table_id);
+		return -1;
+	}
+	filter_priv = sect->priv;
+	tid = h.table_id;
+
+	if (filter_priv->first_ts_id < 0)
+		filter_priv->first_ts_id = h.id;
+	if (filter_priv->first_section < 0)
+		filter_priv->first_section = h.section_id;
+	if (filter_priv->last_section < 0)
+		filter_priv->last_section = h.last_section;
+	else { /* Check if the table was already parsed, but not on first pass */
+		if (!sect->allow_section_gaps && sect->ts_id == -1) {
+			if (test_bit(h.section_id, filter_priv->is_read_bits))
+				return 0;
+		} else if (filter_priv->first_ts_id == h.id && filter_priv->first_section == h.section_id) {
+			/* tables like EIT can increment sections by gaps > 1.
+			 * in this case, reading is done when a already read
+			 * table is reached. */
+			dvb_log("%s: section repeated, reading done", __func__);
+			filter_priv->done = 1;
+			return 1;
+		}
+	}
+
+
+	/* search for an specific TS ID */
+	if (sect->ts_id != -1) {
+		if (h.id != sect->ts_id)
+			return 0;
+	}
+
+	/* handle the sections */
+	if (!sect->allow_section_gaps && sect->ts_id == -1)
+		set_bit(h.section_id, filter_priv->is_read_bits);
+
+	if (dvb_table_initializers[tid].init)
+		dvb_table_initializers[tid].init(parms, buf,
+					    buf_length - DVB_CRC_SIZE,
+					    sect->table);
+	else
+		dvb_logerr("%s: no initializer for table %d",
+			   __func__, tid);
+
+	if (!sect->allow_section_gaps && sect->ts_id == -1 &&
+			is_all_bits_set(filter_priv->last_section, filter_priv->is_read_bits))
+		filter_priv->done = 1;
+
+	if (!filter_priv->done)
+		return 0;
+
+	/* Section was fully parsed */
+	return 1;
+}
+
 int dvb_desc_parse(struct dvb_v5_fe_parms *parms, const uint8_t *buf,
 			   uint16_t buflen, struct dvb_desc **head_desc)
 {
diff --git a/lib/libdvbv5/dvb-scan.c b/lib/libdvbv5/dvb-scan.c
index ba56934..140655d 100644
--- a/lib/libdvbv5/dvb-scan.c
+++ b/lib/libdvbv5/dvb-scan.c
@@ -103,48 +103,6 @@ int dvb_read_section(struct dvb_v5_fe_parms *parms, int dmx_fd,
 	return dvb_read_section_with_id(parms, dmx_fd, tid, pid, -1, table, timeout);
 }
 
-/*
- * The code below was inspired on Linux Kernel's bitmask implementation
- */
-
-#define BITS_PER_LONG		(8 * sizeof(long))
-#define BIT_MASK(nr)		(1UL << ((nr) % BITS_PER_LONG))
-#define BIT_WORD(nr)		((nr) / BITS_PER_LONG)
-#define BITS_TO_LONGS(nr)	((nr +BITS_PER_LONG - 1) / BITS_PER_LONG)
-
-static void set_bit(int nr, unsigned long *addr)
-{
-	unsigned long mask = BIT_MASK(nr);
-	unsigned long *p = addr + BIT_WORD(nr);
-
-	*p  |= mask;
-}
-
-static int test_bit(int nr, unsigned long *addr)
-{
-	unsigned long mask = BIT_MASK(nr);
-	unsigned long *p = addr + BIT_WORD(nr);
-
-	return (*p & mask) ? -1 : 0;
-}
-
-static int is_all_bits_set(int nr, unsigned long *addr)
-{
-	unsigned long mask = BIT_MASK(nr + 1) - 1;
-
-	return (*addr == mask);
-}
-
-
-struct dvb_table_filter_priv {
-	int last_section;
-	unsigned long is_read_bits[BITS_TO_LONGS(256)];
-
-	/* section gaps and multiple ts_id handling */
-	int first_ts_id;
-	int first_section;
-	int done;
-};
 
 static int dvb_parse_section_alloc(struct dvb_v5_fe_parms_priv *parms,
 				   struct dvb_table_filter *sect)
@@ -321,7 +279,12 @@ int dvb_read_sections(struct dvb_v5_fe_parms *__p, int dmx_fd,
 			break;
 		}
 
-		ret = dvb_parse_section(parms, sect, buf, buf_length);
+		if( dvb_table_initializers[sect->tid].parse )
+			ret = dvb_table_initializers[sect->tid].parse(parms, sect, buf, buf_length);
+		else {
+			dvb_logerr("%s: no parser for table id 0x%02x", __func__, sect->tid);
+			ret = -5;
+		}
 	} while (!ret);
 	free(buf);
 	dvb_dmx_stop(dmx_fd);
-- 
1.8.3.2

