From e900d15d5381877843c1115a5bbf59d68596dac0 Mon Sep 17 00:00:00 2001
From: Lars Schmohl <lars.schmohl@gmail.com>
Date: Fri, 8 Jun 2012 10:41:11 +0200
Subject: [PATCH 10/12] sdt and service descriptor

---
 lib/include/descriptors.h               |    9 +-
 lib/include/descriptors/desc_service.h  |   51 +++
 lib/include/descriptors/sdt.h           |   99 ++----
 lib/libdvbv5/Makefile.am                |    4 +-
 lib/libdvbv5/descriptors.c              |  579 ++++++++++++++++---------------
 lib/libdvbv5/descriptors/desc_service.c |   55 +++
 lib/libdvbv5/descriptors/sdt.c          |   88 +++++
 7 files changed, 523 insertions(+), 362 deletions(-)
 create mode 100644 lib/include/descriptors/desc_service.h
 create mode 100644 lib/libdvbv5/descriptors/desc_service.c
 create mode 100644 lib/libdvbv5/descriptors/sdt.c

diff --git a/lib/include/descriptors.h b/lib/include/descriptors.h
index e37b8b0..1c24d1e 100644
--- a/lib/include/descriptors.h
+++ b/lib/include/descriptors.h
@@ -31,7 +31,6 @@
 
 #define DVB_MAX_PAYLOAD_PACKET_SIZE 4096
 #define DVB_PID_SDT      17
-#define DVB_TABLE_SDT    66
 #define DVB_PMT_TABLE_ID 2
 
 typedef void *(*dvb_table_init_func)(const uint8_t *ptr, ssize_t size);
@@ -373,12 +372,12 @@ struct dvb_v5_descriptors {
 };
 
 void parse_descriptor(enum dvb_tables type,
-		      struct dvb_v5_descriptors *dvb_desc,
-		      const unsigned char *buf, int len);
+		struct dvb_v5_descriptors *dvb_desc,
+		const unsigned char *buf, int len);
 
 int has_descriptor(struct dvb_v5_descriptors *dvb_desc,
-		    unsigned char needed_descriptor,
-	            const unsigned char *buf, int len);
+		unsigned char needed_descriptor,
+		const unsigned char *buf, int len);
 
 
 #endif
diff --git a/lib/include/descriptors/desc_service.h b/lib/include/descriptors/desc_service.h
new file mode 100644
index 0000000..53737ed
--- /dev/null
+++ b/lib/include/descriptors/desc_service.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2011-2012 - Mauro Carvalho Chehab <mchehab@redhat.com>
+ * Copyright (c) 2012 - Andre Roth <neolynx@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation version 2
+ * of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ * Or, point your browser to http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+ *
+ */
+
+#ifndef _DESC_SERVICE_H
+#define _DESC_SERVICE_H
+
+#include <stdint.h>
+#include <unistd.h> /* ssize_t */
+
+struct dvb_desc_service {
+	uint8_t type;
+	struct dvb_desc *next;
+
+	uint8_t length;
+	uint8_t service_type;
+	unsigned char provider_name[257];
+	unsigned char service_name[257];
+} __attribute__((packed));
+
+struct dvb_v5_fe_parms;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+	ssize_t dvb_desc_service_init(const uint8_t **buf, struct dvb_desc *desc);
+	void dvb_desc_service_print(struct dvb_v5_fe_parms *parms, const struct dvb_desc *desc);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/lib/include/descriptors/sdt.h b/lib/include/descriptors/sdt.h
index d5e2774..9023c1a 100644
--- a/lib/include/descriptors/sdt.h
+++ b/lib/include/descriptors/sdt.h
@@ -19,90 +19,53 @@
  *
  */
 
-#ifndef _PAT_H
-#define _PAT_H
+#ifndef _SDT_H
+#define _SDT_H
 
 #include <stdint.h>
 #include <unistd.h> /* ssize_t */
 
-struct PAT_Prog {
-	uint16_t program_id;
-	union {
-		uint16_t bitfield;
-		struct {
-			uint16_t pid:13;
-			uint8_t  Reserved:3;
-		} __attribute__((packed));
-	};
+#include "descriptors/header.h"
+#include "descriptors.h"
 
-} __attribute__((packed));
+#define DVB_TABLE_SDT      0x42
+#define DVB_TABLE_SDT_PID  0x11
 
-struct DVB_PAT {
-	uint8_t  table_id;
+struct dvb_table_sdt_service {
+	uint16_t service_id;
+	uint8_t EIT_present_following:1;
+	uint8_t EIT_schedule:1;
+	uint8_t reserved:6;
 	union {
 		uint16_t bitfield;
 		struct {
-			uint16_t section_length:10;
-			uint8_t  zero2:2;
-			uint8_t  one:2;
-			uint8_t  zero:1;
-			uint8_t  syntax:1;
+			uint16_t section_length:12;
+			uint16_t free_CA_mode:1;
+			uint16_t running_status:3;
 		} __attribute__((packed));
 	};
-	uint16_t ts_id;
-	uint8_t  current_next:1;
-	uint8_t  version:5;
-	uint8_t  one2:2;
-	uint8_t  section_id;
-	uint8_t  last_section;
-	struct PAT_Prog  prog[];
+	struct dvb_desc *descriptor;
+	struct dvb_table_sdt_service *next;
+} __attribute__((packed));
 
+struct dvb_table_sdt {
+	struct dvb_table_header header;
+	uint16_t network_id;
+	uint8_t  reserved;
+	struct dvb_table_sdt_service *service;
 } __attribute__((packed));
 
-extern int pat_init(void *ptr, ssize_t size);
+struct dvb_v5_fe_parms;
 
-struct SDT
-{
-  uint8_t  TableID;
-  uint8_t  SectionSyntaxIndicator:1;
-  uint8_t  Reserved1:1;
-  uint8_t  Reserved2:2;
-  uint16_t SectionLength:12;
-  uint16_t TransportStreamID;
-  uint8_t  Reserved3:2;
-  uint8_t  VersionNumber:5;
-  uint8_t  CuurrentNextIndicator:1;
-  uint8_t  SectionNumber;
-  uint8_t  LastSectionNumber;
-  uint16_t OriginalNetworkId;
-  uint8_t  Reserved4;
-  uint8_t  data[];
-} __attribute__((packed));
+#ifdef __cplusplus
+extern "C" {
+#endif
 
-struct SDT_Desc
-{
-  uint16_t ServiceID;
-  uint8_t  Reserved:6;
-  uint8_t  EITScheduleFlag:1;
-  uint8_t  EITPresentFollowingFlag:1;
-  uint8_t  RunningStatus:3;
-  uint8_t  FreeCAMode:1;
-  uint16_t DescriptorsLength:12;
-  uint8_t  data[];
-} __attribute__((packed));
+	void *dvb_table_sdt_init(const uint8_t *buf, ssize_t size);
+	void dvb_table_sdt_print(struct dvb_v5_fe_parms *parms, struct dvb_table_sdt *sdt);
 
-struct SDT_Desc_Data1
-{
-  uint8_t DescriptorTag;
-  uint8_t DescriptorLength;
-  uint8_t ServiceType;
-  uint8_t ServiceProvideLength;
-  uint8_t data[];
-} __attribute__((packed));
-struct SDT_Desc_Data2
-{
-  uint8_t ServiceNameLength;
-  uint8_t data[];
-} __attribute__((packed));
+#ifdef __cplusplus
+}
+#endif
 
 #endif
diff --git a/lib/libdvbv5/Makefile.am b/lib/libdvbv5/Makefile.am
index 7fe0c22..7ab1bfd 100644
--- a/lib/libdvbv5/Makefile.am
+++ b/lib/libdvbv5/Makefile.am
@@ -29,7 +29,9 @@ libdvbv5_la_SOURCES = \
   descriptors/desc_language.c  ../include/descriptors/desc_language.h \
   descriptors/desc_network_name.c  ../include/descriptors/desc_network_name.h \
   descriptors/desc_sat.c  ../include/descriptors/desc_sat.h \
-  descriptors/nit.c  ../include/descriptors/nit.h
+  descriptors/desc_service.c  ../include/descriptors/desc_service.h \
+  descriptors/nit.c  ../include/descriptors/nit.h \
+  descriptors/sdt.c  ../include/descriptors/sdt.h
 
 libdvbv5_la_CPPFLAGS = $(ENFORCE_LIBDVBV5_STATIC)
 libdvbv5_la_LDFLAGS = -version-info 0 $(ENFORCE_LIBDVBV5_STATIC)
diff --git a/lib/libdvbv5/descriptors.c b/lib/libdvbv5/descriptors.c
index 798f877..36a171b 100644
--- a/lib/libdvbv5/descriptors.c
+++ b/lib/libdvbv5/descriptors.c
@@ -34,7 +34,9 @@
 #include "descriptors/desc_language.h"
 #include "descriptors/desc_network_name.h"
 #include "descriptors/desc_sat.h"
+#include "descriptors/desc_service.h"
 #include "descriptors/nit.h"
+#include "descriptors/sdt.h"
 
 void dvb_desc_init(const uint8_t **buf, struct dvb_desc *desc)
 {
@@ -46,6 +48,7 @@ const struct dvb_table_init dvb_table_initializers[] = {
 	[DVB_TABLE_PAT] = { dvb_table_pat_init },
 	[DVB_TABLE_PMT] = { dvb_table_pmt_init },
 	[DVB_TABLE_NIT] = { dvb_table_nit_init },
+	[DVB_TABLE_SDT] = { dvb_table_sdt_init },
 };
 
 static char *default_charset = "iso-8859-1";
@@ -129,7 +132,7 @@ const struct dvb_descriptor dvb_descriptors[] = {
 	[VBI_data_descriptor] = { "VBI_data_descriptor", NULL, NULL },
 	[VBI_teletext_descriptor] = { "VBI_teletext_descriptor", NULL, NULL },
 	[bouquet_name_descriptor] = { "bouquet_name_descriptor", NULL, NULL },
-	[service_descriptor] = { "service_descriptor", NULL, NULL },
+	[service_descriptor] = { "service_descriptor", dvb_desc_service_init, dvb_desc_service_print },
 	[country_availability_descriptor] = { "country_availability_descriptor", NULL, NULL },
 	[linkage_descriptor] = { "linkage_descriptor", NULL, NULL },
 	[NVOD_reference_descriptor] = { "NVOD_reference_descriptor", NULL, NULL },
@@ -287,7 +290,7 @@ static int add_frequency(struct nit_table *nit_table, uint32_t freq)
 	unsigned n = nit_table->frequency_len;
 
 	nit_table->frequency = realloc(nit_table->frequency,
-				       (n + 1) * sizeof(*nit_table->frequency));
+			(n + 1) * sizeof(*nit_table->frequency));
 
 	if (!nit_table->frequency)
 		return -ENOMEM;
@@ -299,8 +302,8 @@ static int add_frequency(struct nit_table *nit_table, uint32_t freq)
 }
 
 static void parse_NIT_ISDBT(struct nit_table *nit_table,
-			     const unsigned char *buf, int dlen,
-			     int verbose)
+		const unsigned char *buf, int dlen,
+		int verbose)
 {
 	uint64_t freq;
 	static const uint32_t interval[] = {
@@ -338,10 +341,10 @@ static void parse_NIT_ISDBT(struct nit_table *nit_table,
 	nit_table->transmission_mode = mode[isdbt_mode];
 	if (verbose)
 		printf("Area code: %d, mode %d (%s), guard interval: %s\n",
-			nit_table->area_code,
-			isdbt_mode + 1,
-			tm_name[nit_table->transmission_mode],
-			interval_name[nit_table->guard_interval]);
+				nit_table->area_code,
+				isdbt_mode + 1,
+				tm_name[nit_table->transmission_mode],
+				interval_name[nit_table->guard_interval]);
 	for (i = 2; i < dlen; i += 2) {
 		buf += 2;
 		/*
@@ -372,8 +375,8 @@ static const unsigned dvbc_dvbs_freq_inner[] = {
 };
 
 static void parse_NIT_DVBS(struct nit_table *nit_table,
-			     const unsigned char *buf, int dlen,
-			     int verbose)
+		const unsigned char *buf, int dlen,
+		int verbose)
 {
 	unsigned orbit, west;
 	uint32_t freq;
@@ -418,18 +421,18 @@ static void parse_NIT_DVBS(struct nit_table *nit_table,
 
 	if (verbose) {
 		printf("DVB-%s orbit %s, freq %d, pol %d, modulation %d, rolloff %d\n",
-		       (nit_table->delivery_system == SYS_DVBS) ? "S" : "S2",
-		       nit_table->orbit, freq,
-		       nit_table->pol, nit_table->modulation,
-		       nit_table->rolloff);
+				(nit_table->delivery_system == SYS_DVBS) ? "S" : "S2",
+				nit_table->orbit, freq,
+				nit_table->pol, nit_table->modulation,
+				nit_table->rolloff);
 		printf("Symbol rate %d, fec_inner %d\n",
-		       nit_table->symbol_rate, nit_table->fec_inner);
+				nit_table->symbol_rate, nit_table->fec_inner);
 	}
 }
 
 static void parse_NIT_DVBC(struct nit_table *nit_table,
-			     const unsigned char *buf, int dlen,
-			     int verbose)
+		const unsigned char *buf, int dlen,
+		int verbose)
 {
 	uint32_t freq;
 	static const unsigned modulation[] = {
@@ -454,17 +457,17 @@ static void parse_NIT_DVBC(struct nit_table *nit_table,
 
 	if (verbose) {
 		printf("DVB-C freq %d, modulation %d, Symbol rate %d\n",
-		       freq,
-		       nit_table->modulation,
-		       nit_table->symbol_rate);
+				freq,
+				nit_table->modulation,
+				nit_table->symbol_rate);
 		printf("fec_inner %d, fec_inner %d\n",
-		       nit_table->fec_inner, nit_table->fec_outer);
+				nit_table->fec_inner, nit_table->fec_outer);
 	}
 }
 
 static void parse_NIT_DVBT(struct nit_table *nit_table,
-			     const unsigned char *buf, int dlen,
-			     int verbose)
+		const unsigned char *buf, int dlen,
+		int verbose)
 {
 	uint32_t freq;
 	static const unsigned bw[] = {
@@ -530,21 +533,21 @@ static void parse_NIT_DVBT(struct nit_table *nit_table,
 
 	if (verbose) {
 		printf("DVB-T freq %d, bandwidth %d modulation %d\n",
-		       freq,
-		       nit_table->bandwidth,
-		       nit_table->modulation);
+				freq,
+				nit_table->bandwidth,
+				nit_table->modulation);
 		printf("hierarchy %d, code rate HP %d, LP %d, guard interval %d\n",
-		       nit_table->hierarchy,
-		       nit_table->code_rate_hp,
-		       nit_table->code_rate_lp,
-		       nit_table->guard_interval);
+				nit_table->hierarchy,
+				nit_table->code_rate_hp,
+				nit_table->code_rate_lp,
+				nit_table->guard_interval);
 		printf("transmission mode %d\n", nit_table->transmission_mode);
 	}
 }
 
 static void parse_NIT_DVBT2(struct nit_table *nit_table,
-			    const unsigned char *buf, int dlen,
-			    int verbose)
+		const unsigned char *buf, int dlen,
+		int verbose)
 {
 	static const unsigned bw[] = {
 		[0] =  8000000,
@@ -597,8 +600,8 @@ static void parse_NIT_DVBT2(struct nit_table *nit_table,
 }
 
 static void parse_freq_list(struct nit_table *nit_table,
-			    const unsigned char *buf, int dlen,
-			    int verbose)
+		const unsigned char *buf, int dlen,
+		int verbose)
 {
 	int i;
 	uint32_t freq;
@@ -616,8 +619,8 @@ static void parse_freq_list(struct nit_table *nit_table,
 }
 
 static void parse_partial_reception(struct nit_table *nit_table,
-				    const unsigned char *buf, int dlen,
-				    int verbose)
+		const unsigned char *buf, int dlen,
+		int verbose)
 {
 	int i;
 	uint16_t **pid = &nit_table->partial_reception;
@@ -629,15 +632,15 @@ static void parse_partial_reception(struct nit_table *nit_table,
 		nit_table->partial_reception[*n] = buf[i] << 8 | buf[i + 1];
 		if (verbose)
 			printf("Service 0x%04x has partial reception\n",
-			       nit_table->partial_reception[*n]);
+					nit_table->partial_reception[*n]);
 		buf += 2;
 		(*n)++;
 	}
 }
 
 static int parse_extension_descriptor(enum dvb_tables type,
-				       struct dvb_v5_descriptors *dvb_desc,
-				       const unsigned char *buf, int dlen)
+		struct dvb_v5_descriptors *dvb_desc,
+		const unsigned char *buf, int dlen)
 {
 	unsigned char ext = buf[0];
 	int i;
@@ -651,7 +654,7 @@ static int parse_extension_descriptor(enum dvb_tables type,
 
 	if (dvb_desc->verbose) {
 		printf("Extension descriptor %s (0x%02x), len %d",
-			extension_descriptors[ext], ext, dlen);
+				extension_descriptors[ext], ext, dlen);
 		for (i = 0; i < dlen; i++) {
 			if (!(i % 16))
 				printf("\n\t");
@@ -660,23 +663,23 @@ static int parse_extension_descriptor(enum dvb_tables type,
 		printf("\n");
 	}
 	switch(ext) {
-	case T2_delivery_system_descriptor:
-		if (type != NIT)
-			return 1;
+		case T2_delivery_system_descriptor:
+			if (type != NIT)
+				return 1;
 
-		parse_NIT_DVBT2(&dvb_desc->nit_table, buf, dlen,
-				dvb_desc->verbose);
-		break;
+			parse_NIT_DVBT2(&dvb_desc->nit_table, buf, dlen,
+					dvb_desc->verbose);
+			break;
 	}
 
 	return 0;
 };
 
 static void parse_net_name(struct nit_table *nit_table,
-			   const unsigned char *buf, int dlen, int verbose)
+		const unsigned char *buf, int dlen, int verbose)
 {
 	parse_string(&nit_table->network_name, &nit_table->network_alias,
-		     &buf[2], dlen, default_charset, output_charset);
+			&buf[2], dlen, default_charset, output_charset);
 	if (verbose) {
 		printf("Network");
 		if (nit_table->network_name)
@@ -691,7 +694,7 @@ static void parse_net_name(struct nit_table *nit_table,
 
 
 static void parse_lcn(struct nit_table *nit_table,
-		      const unsigned char *buf, int dlen, int verbose)
+		const unsigned char *buf, int dlen, int verbose)
 {
 	int i, n = nit_table->lcn_len;
 	const unsigned char *p = &buf[2];
@@ -708,24 +711,24 @@ static void parse_lcn(struct nit_table *nit_table,
 
 		if (verbose)
 			printf("Service ID: 0x%04x, LCN: %d\n",
-			       (*lcn)[n].service_id,
-			       (*lcn)[n].lcn);
+					(*lcn)[n].service_id,
+					(*lcn)[n].lcn);
 	}
 }
 
 static void parse_service(struct service_table *service_table,
-			  const unsigned char *buf, int dlen, int verbose)
+		const unsigned char *buf, int dlen, int verbose)
 {
 	service_table->type = buf[2];
 	parse_string(&service_table->provider_name,
-		     &service_table->provider_alias,
-		     &buf[4], buf[3],
-		     default_charset, output_charset);
+			&service_table->provider_alias,
+			&buf[4], buf[3],
+			default_charset, output_charset);
 	buf += 4 + buf[3];
 	parse_string(&service_table->service_name,
-		     &service_table->service_alias,
-		     &buf[1], buf[0],
-		     default_charset, output_charset);
+			&service_table->service_alias,
+			&buf[1], buf[0],
+			default_charset, output_charset);
 	if (verbose) {
 		if (service_table->provider_name)
 			printf("Provider %s", service_table->provider_name);
@@ -738,17 +741,17 @@ static void parse_service(struct service_table *service_table,
 		if (service_table->service_alias)
 			printf("(%s)", service_table->service_alias);
 		if (!service_table->provider_name &&
-		    !service_table->service_alias &&
-		    !service_table->service_name &&
-		    !service_table->service_alias)
+				!service_table->service_alias &&
+				!service_table->service_name &&
+				!service_table->service_alias)
 			printf("Service 0x%04x", service_table->service_id);
 		printf("\n");
 	}
 }
 
 void parse_descriptor(enum dvb_tables type,
-			     struct dvb_v5_descriptors *dvb_desc,
-			     const unsigned char *buf, int len)
+		struct dvb_v5_descriptors *dvb_desc,
+		const unsigned char *buf, int len)
 {
 	int i;
 
@@ -763,12 +766,12 @@ void parse_descriptor(enum dvb_tables type,
 
 		if (dlen > len) {
 			fprintf(stderr, "descriptor size %d is longer than %d!\n",
-				dlen, len);
+					dlen, len);
 			return;
 		}
 		if (dvb_desc->verbose) {
 			printf("%s (0x%02x), len %d",
-			       dvb_descriptors[buf[0]].name, buf[0], buf[1]);
+					dvb_descriptors[buf[0]].name, buf[0], buf[1]);
 			for (i = 0; i < dlen; i++) {
 				if (!(i % 16))
 					printf("\n\t");
@@ -777,140 +780,140 @@ void parse_descriptor(enum dvb_tables type,
 			printf("\n");
 		}
 		switch(buf[0]) {
-		case extension_descriptor:
-			err = parse_extension_descriptor(type, dvb_desc,
-							 &buf[2], dlen);
-			break;
-		case iso639_language_descriptor:
-		{
-			int i;
-			const unsigned char *p = &buf[2];
-
-			if (dvb_desc->verbose) {
-				for (i = 0; i < dlen; i+= 4, p += 4) {
-					printf("Language = %c%c%c, amode = %d\n",
-						p[0], p[1], p[2], p[3]);
+			case extension_descriptor:
+				err = parse_extension_descriptor(type, dvb_desc,
+						&buf[2], dlen);
+				break;
+			case iso639_language_descriptor:
+				{
+					int i;
+					const unsigned char *p = &buf[2];
+
+					if (dvb_desc->verbose) {
+						for (i = 0; i < dlen; i+= 4, p += 4) {
+							printf("Language = %c%c%c, amode = %d\n",
+									p[0], p[1], p[2], p[3]);
+						}
+					}
+					break;
 				}
-			}
-			break;
-		}
-		case AAC_descriptor:
-			if (dvb_desc->verbose)
-				printf("AAC descriptor with len %d\n", dlen);
-			break;
-		case stream_identifier_descriptor:
-			/* Don't need to parse it */
-			if (dvb_desc->verbose)
-				printf("Component tag 0x%02x\n", buf[2]);
-			break;
-		case network_name_descriptor:
-			if (type != NIT) {
-				err = 1;
+			case AAC_descriptor:
+				if (dvb_desc->verbose)
+					printf("AAC descriptor with len %d\n", dlen);
 				break;
-			}
-			parse_net_name(&dvb_desc->nit_table, buf, dlen,
-				       dvb_desc->verbose);
-			break;
-
-		/* DVB NIT decoders */
-		case satellite_delivery_system_descriptor:
-			if (type != NIT) {
-				err = 1;
+			case stream_identifier_descriptor:
+				/* Don't need to parse it */
+				if (dvb_desc->verbose)
+					printf("Component tag 0x%02x\n", buf[2]);
 				break;
-			}
-			parse_NIT_DVBS(&dvb_desc->nit_table, buf, dlen,
-				       dvb_desc->verbose);
-			break;
-		case cable_delivery_system_descriptor:
-			if (type != NIT) {
-				err = 1;
-				break;
-			}
-			parse_NIT_DVBC(&dvb_desc->nit_table, buf, dlen,
-				       dvb_desc->verbose);
-			break;
-		case terrestrial_delivery_system_descriptor:
-			if (type != NIT) {
-				err = 1;
+			case network_name_descriptor:
+				if (type != NIT) {
+					err = 1;
+					break;
+				}
+				parse_net_name(&dvb_desc->nit_table, buf, dlen,
+						dvb_desc->verbose);
 				break;
-			}
-			parse_NIT_DVBT(&dvb_desc->nit_table, buf, dlen,
-				       dvb_desc->verbose);
-			break;
 
-		/* ISDBT NIT decoders */
-		case ISDBT_delivery_system_descriptor:
-			if (type != NIT) {
-				err = 1;
+				/* DVB NIT decoders */
+			case satellite_delivery_system_descriptor:
+				if (type != NIT) {
+					err = 1;
+					break;
+				}
+				parse_NIT_DVBS(&dvb_desc->nit_table, buf, dlen,
+						dvb_desc->verbose);
 				break;
-			}
-
-			parse_NIT_ISDBT(&dvb_desc->nit_table, buf, dlen,
-					dvb_desc->verbose);
-			break;
-		case partial_reception_descriptor:
-			if (type != NIT) {
-				err = 1;
+			case cable_delivery_system_descriptor:
+				if (type != NIT) {
+					err = 1;
+					break;
+				}
+				parse_NIT_DVBC(&dvb_desc->nit_table, buf, dlen,
+						dvb_desc->verbose);
 				break;
-			}
-			parse_partial_reception(&dvb_desc->nit_table, buf, dlen,
+			case terrestrial_delivery_system_descriptor:
+				if (type != NIT) {
+					err = 1;
+					break;
+				}
+				parse_NIT_DVBT(&dvb_desc->nit_table, buf, dlen,
 						dvb_desc->verbose);
-			break;
+				break;
+
+				/* ISDBT NIT decoders */
+			case ISDBT_delivery_system_descriptor:
+				if (type != NIT) {
+					err = 1;
+					break;
+				}
 
-		/* LCN decoder */
-		case logical_channel_number_descriptor:
-		{
-			/*
-			 * According with SCTE 57 2011, descriptor 0x83
-			 * is the extended video descriptor. We don't need
-			 * it, but don't print an error for this condition.
-			 */
-			if (type == PMT)
+				parse_NIT_ISDBT(&dvb_desc->nit_table, buf, dlen,
+						dvb_desc->verbose);
 				break;
-			if (type != NIT) {
-				err = 1;
+			case partial_reception_descriptor:
+				if (type != NIT) {
+					err = 1;
+					break;
+				}
+				parse_partial_reception(&dvb_desc->nit_table, buf, dlen,
+						dvb_desc->verbose);
 				break;
-			}
-			parse_lcn(&dvb_desc->nit_table, buf, dlen,
-				  dvb_desc->verbose);
-			break;
-		}
 
-		case TS_Information_descriptior:
-			if (type != NIT) {
-				err = 1;
-				break;
-			}
-			dvb_desc->nit_table.virtual_channel = buf[2];
-			if (dvb_desc->verbose)
-				printf("Virtual channel = %d\n", buf[2]);
-			break;
+				/* LCN decoder */
+			case logical_channel_number_descriptor:
+				{
+					/*
+					 * According with SCTE 57 2011, descriptor 0x83
+					 * is the extended video descriptor. We don't need
+					 * it, but don't print an error for this condition.
+					 */
+					if (type == PMT)
+						break;
+					if (type != NIT) {
+						err = 1;
+						break;
+					}
+					parse_lcn(&dvb_desc->nit_table, buf, dlen,
+							dvb_desc->verbose);
+					break;
+				}
 
-		case frequency_list_descriptor:
-			if (type != NIT) {
-				err = 1;
+			case TS_Information_descriptior:
+				if (type != NIT) {
+					err = 1;
+					break;
+				}
+				dvb_desc->nit_table.virtual_channel = buf[2];
+				if (dvb_desc->verbose)
+					printf("Virtual channel = %d\n", buf[2]);
 				break;
-			}
-			parse_freq_list(&dvb_desc->nit_table, buf, dlen,
-					dvb_desc->verbose);
-			break;
 
-		case service_descriptor: {
-			if (type != SDT) {
-				err = 1;
+			case frequency_list_descriptor:
+				if (type != NIT) {
+					err = 1;
+					break;
+				}
+				parse_freq_list(&dvb_desc->nit_table, buf, dlen,
+						dvb_desc->verbose);
 				break;
-			}
-			parse_service(&dvb_desc->sdt_table.service_table[dvb_desc->cur_service],
-				      buf, dlen, dvb_desc->verbose);
-			break;
-		}
-		default:
-			break;
+
+			case service_descriptor: {
+							 if (type != SDT) {
+								 err = 1;
+								 break;
+							 }
+							 parse_service(&dvb_desc->sdt_table.service_table[dvb_desc->cur_service],
+									 buf, dlen, dvb_desc->verbose);
+							 break;
+						 }
+			default:
+						 break;
 		}
 		if (err) {
 			fprintf(stderr,
-				"descriptor %s is invalid on %s table\n",
-				dvb_descriptors[buf[0]].name, table[type]);
+					"descriptor %s is invalid on %s table\n",
+					dvb_descriptors[buf[0]].name, table[type]);
 		}
 		buf += dlen + 2;
 		len -= dlen + 2;
@@ -918,8 +921,8 @@ void parse_descriptor(enum dvb_tables type,
 }
 
 int has_descriptor(struct dvb_v5_descriptors *dvb_desc,
-		    unsigned char needed_descriptor,
-	            const unsigned char *buf, int len)
+		unsigned char needed_descriptor,
+		const unsigned char *buf, int len)
 {
 	if (len == 0)
 		return 0;
@@ -938,110 +941,110 @@ int has_descriptor(struct dvb_v5_descriptors *dvb_desc,
 }
 
 #if 0
-	/* TODO: remove those stuff */
-
-		case ds_alignment_descriptor:
-		case dvbpsi_registration_descriptor:
-		case service_list_descriptor:
-		case stuffing_descriptor:
-		case VBI_data_descriptor:
-		case VBI_teletext_descriptor:
-		case bouquet_name_descriptor:
-		case country_availability_descriptor:
-		case linkage_descriptor:
-		case NVOD_reference_descriptor:
-		case time_shifted_service_descriptor:
-		case short_event_descriptor:
-		case extended_event_descriptor:
-		case time_shifted_event_descriptor:
-		case component_descriptor:
-		case mosaic_descriptor:
-		case CA_identifier_descriptor:
-		case content_descriptor:
-		case parental_rating_descriptor:
-		case teletext_descriptor:
-		case telephone_descriptor:
-		case local_time_offset_descriptor:
-		case subtitling_descriptor:
-		case multilingual_network_name_descriptor:
-		case multilingual_bouquet_name_descriptor:
-		case multilingual_service_name_descriptor:
-		case multilingual_component_descriptor:
-		case private_data_specifier_descriptor:
-		case service_move_descriptor:
-		case short_smoothing_buffer_descriptor:
-		case partial_transport_stream_descriptor:
-		case data_broadcast_descriptor:
-		case scrambling_descriptor:
-		case data_broadcast_id_descriptor:
-		case transport_stream_descriptor:
-		case DSNG_descriptor:
-		case PDC_descriptor:
-		case AC_3_descriptor:
-		case ancillary_data_descriptor:
-		case cell_list_descriptor:
-		case cell_frequency_link_descriptor:
-		case announcement_support_descriptor:
-		case application_signalling_descriptor:
-		case adaptation_field_data_descriptor:
-		case service_identifier_descriptor:
-		case service_availability_descriptor:
-		case default_authority_descriptor:
-		case related_content_descriptor:
-		case TVA_id_descriptor:
-		case content_identifier_descriptor:
-		case time_slice_fec_identifier_descriptor:
-		case ECM_repetition_rate_descriptor:
-		case S2_satellite_delivery_system_descriptor:
-		case enhanced_AC_3_descriptor:
-		case DTS_descriptor:
-		case XAIT_location_descriptor:
-		case FTA_content_management_descriptor:
-		case extension_descriptor:
-
-		case CUE_identifier_descriptor:
-		case component_name_descriptor:
-		case conditional_access_descriptor:
-		case copyright_descriptor:
-		case carousel_id_descriptor:
-		case association_tag_descriptor:
-		case deferred_association_tags_descriptor:
-		case AVC_video_descriptor:
-		case AVC_timing_and_HRD_descriptor:
-		case hierarchical_transmission_descriptor:
-		case digital_copy_control_descriptor:
-		case network_identifier_descriptor:
-		case partial_transport_stream_time_descriptor:
-		case audio_component_descriptor:
-		case hyperlink_descriptor:
-		case target_area_descriptor:
-		case data_contents_descriptor:
-		case video_decode_control_descriptor:
-		case download_content_descriptor:
-		case CA_EMM_TS_descriptor:
-		case CA_contract_information_descriptor:
-		case CA_service_descriptor:
-		case extended_broadcaster_descriptor:
-		case logo_transmission_descriptor:
-		case basic_local_event_descriptor:
-		case reference_descriptor:
-		case node_relation_descriptor:
-		case short_node_information_descriptor:
-		case STC_reference_descriptor:
-		case series_descriptor:
-		case event_group_descriptor:
-		case SI_parameter_descriptor:
-		case broadcaster_Name_Descriptor:
-		case component_group_descriptor:
-		case SI_prime_TS_descriptor:
-		case board_information_descriptor:
-		case LDT_linkage_descriptor:
-		case connected_transmission_descriptor:
-		case content_availability_descriptor:
-		case service_group_descriptor:
-		case carousel_compatible_composite_Descriptor:
-		case conditional_playback_descriptor:
-		case emergency_information_descriptor:
-		case data_component_descriptor:
-		case system_management_descriptor:
+/* TODO: remove those stuff */
+
+case ds_alignment_descriptor:
+case dvbpsi_registration_descriptor:
+case service_list_descriptor:
+case stuffing_descriptor:
+case VBI_data_descriptor:
+case VBI_teletext_descriptor:
+case bouquet_name_descriptor:
+case country_availability_descriptor:
+case linkage_descriptor:
+case NVOD_reference_descriptor:
+case time_shifted_service_descriptor:
+case short_event_descriptor:
+case extended_event_descriptor:
+case time_shifted_event_descriptor:
+case component_descriptor:
+case mosaic_descriptor:
+case CA_identifier_descriptor:
+case content_descriptor:
+case parental_rating_descriptor:
+case teletext_descriptor:
+case telephone_descriptor:
+case local_time_offset_descriptor:
+case subtitling_descriptor:
+case multilingual_network_name_descriptor:
+case multilingual_bouquet_name_descriptor:
+case multilingual_service_name_descriptor:
+case multilingual_component_descriptor:
+case private_data_specifier_descriptor:
+case service_move_descriptor:
+case short_smoothing_buffer_descriptor:
+case partial_transport_stream_descriptor:
+case data_broadcast_descriptor:
+case scrambling_descriptor:
+case data_broadcast_id_descriptor:
+case transport_stream_descriptor:
+case DSNG_descriptor:
+case PDC_descriptor:
+case AC_3_descriptor:
+case ancillary_data_descriptor:
+case cell_list_descriptor:
+case cell_frequency_link_descriptor:
+case announcement_support_descriptor:
+case application_signalling_descriptor:
+case adaptation_field_data_descriptor:
+case service_identifier_descriptor:
+case service_availability_descriptor:
+case default_authority_descriptor:
+case related_content_descriptor:
+case TVA_id_descriptor:
+case content_identifier_descriptor:
+case time_slice_fec_identifier_descriptor:
+case ECM_repetition_rate_descriptor:
+case S2_satellite_delivery_system_descriptor:
+case enhanced_AC_3_descriptor:
+case DTS_descriptor:
+case XAIT_location_descriptor:
+case FTA_content_management_descriptor:
+case extension_descriptor:
+
+case CUE_identifier_descriptor:
+case component_name_descriptor:
+case conditional_access_descriptor:
+case copyright_descriptor:
+case carousel_id_descriptor:
+case association_tag_descriptor:
+case deferred_association_tags_descriptor:
+case AVC_video_descriptor:
+case AVC_timing_and_HRD_descriptor:
+case hierarchical_transmission_descriptor:
+case digital_copy_control_descriptor:
+case network_identifier_descriptor:
+case partial_transport_stream_time_descriptor:
+case audio_component_descriptor:
+case hyperlink_descriptor:
+case target_area_descriptor:
+case data_contents_descriptor:
+case video_decode_control_descriptor:
+case download_content_descriptor:
+case CA_EMM_TS_descriptor:
+case CA_contract_information_descriptor:
+case CA_service_descriptor:
+case extended_broadcaster_descriptor:
+case logo_transmission_descriptor:
+case basic_local_event_descriptor:
+case reference_descriptor:
+case node_relation_descriptor:
+case short_node_information_descriptor:
+case STC_reference_descriptor:
+case series_descriptor:
+case event_group_descriptor:
+case SI_parameter_descriptor:
+case broadcaster_Name_Descriptor:
+case component_group_descriptor:
+case SI_prime_TS_descriptor:
+case board_information_descriptor:
+case LDT_linkage_descriptor:
+case connected_transmission_descriptor:
+case content_availability_descriptor:
+case service_group_descriptor:
+case carousel_compatible_composite_Descriptor:
+case conditional_playback_descriptor:
+case emergency_information_descriptor:
+case data_component_descriptor:
+case system_management_descriptor:
 #endif
diff --git a/lib/libdvbv5/descriptors/desc_service.c b/lib/libdvbv5/descriptors/desc_service.c
new file mode 100644
index 0000000..38930b0
--- /dev/null
+++ b/lib/libdvbv5/descriptors/desc_service.c
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2011-2012 - Mauro Carvalho Chehab <mchehab@redhat.com>
+ * Copyright (c) 2012 - Andre Roth <neolynx@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation version 2
+ * of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ * Or, point your browser to http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+ *
+ */
+
+#include "descriptors/desc_service.h"
+#include "descriptors.h"
+#include "dvb-fe.h"
+
+ssize_t dvb_desc_service_init(const uint8_t **buf, struct dvb_desc *desc)
+{
+	dvb_desc_init(buf, desc);
+	struct dvb_desc_service *service = (struct dvb_desc_service *) desc;
+
+	service->length = (*buf)[1];
+	service->service_type = (*buf)[2];
+	*buf += 3;
+
+	uint8_t len = (*buf)[0];
+	memcpy(service->provider_name, (*buf) + 1, len);
+	service->provider_name[len] = '\0';
+	*buf += len + 1;
+
+	len = (*buf)[0];
+	memcpy(service->service_name, (*buf) + 1, len);
+	service->service_name[len] = '\0';
+	*buf += len + 1;
+	return sizeof(struct dvb_desc_service);
+}
+
+void dvb_desc_service_print(struct dvb_v5_fe_parms *parms, const struct dvb_desc *desc)
+{
+	const struct dvb_desc_service *srv = (const struct dvb_desc_service *) desc;
+	dvb_log("|           type    : '%d'", srv->service_type);
+	dvb_log("|           length  : '%d'", srv->length);
+	dvb_log("|           provider: '%s'", srv->provider_name);
+	dvb_log("|           service : '%s'", srv->service_name);
+}
+
diff --git a/lib/libdvbv5/descriptors/sdt.c b/lib/libdvbv5/descriptors/sdt.c
new file mode 100644
index 0000000..533ef3f
--- /dev/null
+++ b/lib/libdvbv5/descriptors/sdt.c
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2011-2012 - Mauro Carvalho Chehab <mchehab@redhat.com>
+ * Copyright (c) 2012 - Andre Roth <neolynx@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation version 2
+ * of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ * Or, point your browser to http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+ *
+ */
+
+#include "descriptors/sdt.h"
+#include "dvb-fe.h"
+
+void *dvb_table_sdt_init(const uint8_t *buf, ssize_t size)
+{
+	uint8_t *d = malloc(DVB_MAX_PAYLOAD_PACKET_SIZE * 2);
+	const uint8_t *p = buf;
+	struct dvb_table_sdt *sdt = (struct dvb_table_sdt *) d;
+
+	memcpy(sdt, p, sizeof(struct dvb_table_sdt) - sizeof(sdt->service));
+	p += sizeof(struct dvb_table_sdt) - sizeof(sdt->service);
+	d += sizeof(struct dvb_table_sdt);
+
+	dvb_table_header_init(&sdt->header);
+	sdt->service = NULL;
+
+	struct dvb_table_sdt_service *last = NULL;
+	struct dvb_table_sdt_service **head = &sdt->service;
+	while ((uint8_t *) p < buf + size - 4) {
+		struct dvb_table_sdt_service *service = (struct dvb_table_sdt_service *) d;
+		memcpy(d, p, sizeof(struct dvb_table_sdt_service) - sizeof(service->descriptor) - sizeof(service->next));
+		p += sizeof(struct dvb_table_sdt_service) - sizeof(service->descriptor) - sizeof(service->next);
+		d += sizeof(struct dvb_table_sdt_service);
+
+		bswap16(service->service_id);
+		bswap16(service->bitfield);
+		service->descriptor = NULL;
+		service->next = NULL;
+
+		if(!*head)
+			*head = service;
+		if(last)
+			last->next = service;
+
+		/* get the descriptors for each program */
+		struct dvb_desc **head_desc = &service->descriptor;
+		d += dvb_parse_descriptor(p, d, service->section_length, head_desc);
+
+		p += service->section_length;
+		last = service;
+	}
+	return sdt;
+}
+
+void dvb_table_sdt_print(struct dvb_v5_fe_parms *parms, struct dvb_table_sdt *sdt)
+{
+	dvb_log("SDT");
+	dvb_table_header_print(parms, &sdt->header);
+	dvb_log("|\\  service_id");
+	const struct dvb_table_sdt_service *service = sdt->service;
+	uint16_t services = 0;
+	while(service) {
+		dvb_log("|- %7d", service->service_id);
+		dvb_log("|   EIT_schedule: %d", service->EIT_schedule);
+		dvb_log("|   EIT_present_following: %d", service->EIT_present_following);
+		struct dvb_desc *desc = service->descriptor;
+		while (desc) {
+			if (dvb_descriptors[desc->type].print)
+				dvb_descriptors[desc->type].print(parms, desc);
+			desc = desc->next;
+		}
+		service = service->next;
+		services++;
+	}
+	dvb_log("|_  %d services", services);
+}
+
-- 
1.7.9.5

